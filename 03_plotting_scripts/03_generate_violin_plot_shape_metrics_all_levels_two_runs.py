"""
Load "csa-SC_T2w_perlevel" CSV file with shape metrics perlevel located under "-path-in/results" and generate group
figures comparing run 1 vs run 2.

Rows represent vertebral levels (C2-C7)
Columns represent shape metrics (CSA, diameter_AP, ..)

The figures are saved in "-path-out".

Authors: Jan Valosek
"""

import os
import re
import sys
import argparse
import logging

import numpy as np
import pandas as pd
import seaborn as sns  # seaborn>=0.13.0 is required to properly create the figure
import matplotlib as mpl
import matplotlib.pyplot as plt

from scipy.stats import normaltest, ttest_rel, wilcoxon

# Get the name of the directory where this script is present
current = os.path.dirname(os.path.realpath(__file__))
# Get the parent directory name
parent = os.path.dirname(current)
# Add the parent directory to the sys.path to import the utils module
sys.path.append(parent)

# Vertebral levels (C2-C7)
LEVELS = [2, 3, 4, 5, 6, 7]

# METRICS = ['MEAN(area)', 'MEAN(diameter_AP)', 'MEAN(diameter_RL)', 'MEAN(compression_ratio)', 'MEAN(eccentricity)',
#            'MEAN(solidity)']
METRICS = ['MEAN(area)']

METRIC_TO_AXIS = {
    'MEAN(diameter_AP)': 'AP Diameter [mm]',
    'MEAN(area)': 'Cross-Sectional Area [mm²]',
    'MEAN(diameter_RL)': 'Transverse Diameter [mm]',
    'MEAN(eccentricity)': 'Eccentricity [a.u.]',
    'MEAN(solidity)': 'Solidity [%]',
    'MEAN(compression_ratio)': 'Compression Ratio [a.u.]',
}

TITLE_FONT_SIZE = 12
LABELS_FONT_SIZE = 10
TEXT_FONT_SIZE = 8

# NOTE: for some reason, the color order must be swapped here. Maybe due to the `.invert_xaxis` method?
color_palette = {
    'run-01': (0.5529411764705883, 0.8274509803921568, 0.7803921568627451),  # red
    'run-02': (0.984313725490196, 0.5019607843137255, 0.4470588235294118)  # green
}

# Initialize logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)  # default: logging.DEBUG, logging.INFO
hdlr = logging.StreamHandler(sys.stdout)
logging.root.addHandler(hdlr)


def get_parser():
    """
    Input argument parser function
    """
    parser = argparse.ArgumentParser(
        description='Load "csa-SC_T2w_perlevel" CSV file with shape metrics perlevel located under "-path-in/results" '
                    'and generate group figure comparing run 1 vs run 2.'
                    'The figure will be saved in the same directory as the input CSV file.')
    parser.add_argument(
        '-i',
        metavar="<file>",
        required=True,
        type=str,
        help='Path to the "csa-SC_T2w_perlevel" CSV file produced by sct_run_batch. '
             'Example: "/Users/user/results/dcm-brno_2024-02-19/results/"csa-SC_T2w_perlevel"')
    return parser


def fetch_participant_and_run(filename_path):
    """
    Get participant_id and run_id from the input BIDS-compatible filename or file path
    The function works both on absolute file path and filename
    More about BIDS - https://bids-specification.readthedocs.io/en/stable/04-modality-specific-files/01-magnetic-resonance-imaging-data.html#anatomy-imaging-data

    :param filename_path: e.g., '~/data_processed/sub-1860B6472B/ses-6472B/dwi/sub-1860B6472B_ses-6472B_run-01_T2w.nii.gz'
    :return: participant_id: e.g., 'sub-1860B6472B'
    :return: run_id: run ID (e.g., run-01)
    """

    participant_tmp = re.search('sub-(.*?)[_/]', filename_path)  # [_/] slash or underscore
    participant_id = participant_tmp.group(0)[
                     :-1] if participant_tmp else ""  # [:-1] removes the last underscore or slash

    run_tmp = re.search('run-(.*?)[_/]', filename_path)  # [_/] means either underscore or slash
    run_id = run_tmp.group(0)[:-1] if run_tmp else ""  # [:-1] removes the last underscore or slash
    # REGEX explanation
    # . - match any character (except newline)
    # *? - match the previous element as few times as possible (zero or more times)

    return participant_id, run_id


def read_metrics(csv_file_path, vert_level=None):
    """
    Read shape metrics (CSA, diameter_AP, ...) from the "csa-SC_T2w_perlevel" CSV file generated by
    SCT's sct_process_segmentation
    Compute compression ratio (CR) as MEAN(diameter_AP) / MEAN(diameter_RL)
    Keep only VertLevel specified by vert_level

    :param csv_file_path: Path to the "csa-SC_T2w_perlevel" CSV file
    :param vert_level: Vertebrae level to keep. Examples: 3 (meaning C3), 4 (meaning C4), etc.
    :return: df: DataFrame with shape metrics
    """

    metrics_dtype = {
        'MEAN(diameter_AP)': 'float64',
        'MEAN(area)': 'float64',
        'MEAN(diameter_RL)': 'float64',
        'MEAN(eccentricity)': 'float64',
        'MEAN(solidity)': 'float64'
    }

    # Read the "csa-SC_T2w_perlevel" CSV file
    df = pd.read_csv(csv_file_path, dtype=metrics_dtype)

    # Fetch participant and run using lambda function
    df['Participant'], df['Run'] = zip(*df['Filename'].map(lambda x: fetch_participant_and_run(x)))

    # Compute compression ratio (CR) as MEAN(diameter_AP) / MEAN(diameter_RL)
    df['MEAN(compression_ratio)'] = df['MEAN(diameter_AP)'] / df['MEAN(diameter_RL)']

    # Drop columns
    df.drop(columns=['Filename', 'Timestamp', 'SCT Version', 'DistancePMJ'], inplace=True)

    # Keep specific vert level if vert_level is provided
    if vert_level is not None:
        df = df[df['VertLevel'] == vert_level]

    return df


def generate_figure(df, summary, fname_out):
    """
    Generate 6x6 group figure (swarmplot + lineplot) comparing run1 vs run2 for 6 shape metrics
    Rows represent vertebral levels (C2-C7)
    Columns represent shape metrics (CSA, diameter_AP, ..)

    :param df: DataFrame with shape metrics
    :param summary: Summary statistics for each VertLevel
    :param fname_out: Output figure file name
    """

    # Generate 6x6 group figure comparing run 1 vs run 2 for 6 shape metrics
    mpl.rcParams['font.family'] = 'Arial'

    fig, axes = plt.subplots(len(METRICS), len(LEVELS), figsize=(2 * len(LEVELS), 3 * len(METRICS)), sharey='row')
    # Force axs to be a 2-dimensional array (to avoid indexing issues if we have only a subject)
    axs = np.asanyarray(axes).reshape((len(LEVELS), len(METRICS)))
    # Loop across vertebral levels (C2-C7)
    for index_row, level in enumerate(LEVELS):
        # Keep only one specific vert level
        df_level = df[df['VertLevel'] == level]
        # Loop across metrics (CSA, diameter_AP, ...)
        for index_col, metric in enumerate(METRICS):
            print(f'Plotting C{level}, {metric}...')
            kwargs = dict(x='Run', y=metric, ax=axs[index_row, index_col], data=df_level)
            # Plot swarmplot on top of the violin plot
            sns.swarmplot(color='black',
                          alpha=0.5,
                          **kwargs)
            # Plot lineplot connecting points of the same subject between runs
            sns.lineplot(units='Participant',
                         estimator=None,
                         legend=False,
                         linewidth=0.5,
                         color='black',
                         alpha=0.5,
                         **kwargs)

            axs[index_row, index_col].set_xlabel(f'C{level}')
            # Add title to each row, (i.e., y-axis)
            if index_col == 0:
                ylabel = f'{METRIC_TO_AXIS[metric]}'
            else:
                ylabel = METRIC_TO_AXIS[metric]
            axs[index_row, index_col].set_ylabel(ylabel, fontsize=LABELS_FONT_SIZE)

            axs[index_row, index_col].tick_params(axis='both', which='major', labelsize=TEXT_FONT_SIZE)

            # Add percentage change to the plot
            mean_diff = summary.loc[level, 'Percent_Change_mean']
            std_diff = summary.loc[level, 'Percent_Change_std']
            axs[index_row, index_col].text(0.5, 0.95, f'{mean_diff:.2f} ± {std_diff:.2f}%',
                                           horizontalalignment='center',
                                           verticalalignment='center',
                                           transform=axs[index_row, index_col].transAxes,
                                           fontsize=TEXT_FONT_SIZE)

    # # Set main title with number of subjects
    # fig.suptitle(f'T2w shape metrics across vertebral levels\n'
    #              f'Number of subjects: {number_of_subjects}',
    #              fontsize=TITLE_FONT_SIZE)

    # Save the figure
    fig.tight_layout()
    fig.savefig(fname_out, dpi=300)
    plt.close(fig)
    logger.info(f'Figure saved to {fname_out}')


def compute_difference_between_runs(df):
    """
    Compute differences and percent changes between run-01 and run-02.
    Group by VertLevel and calculate summary statistics across participants.

    :param df: DataFrame with shape metrics
    :return: summary: Summary statistics for each VertLevel
    """
    # Pivot the data to have run-01 and run-02 side by side
    pivot_df = df.pivot_table(values='MEAN(area)', index=['Participant', 'VertLevel'], columns='Run')

    # Calculate differences and percent changes between run-01 and run-02 for each participant
    pivot_df['Difference'] = pivot_df['run-02'] - pivot_df['run-01']
    pivot_df['Percent_Change'] = (pivot_df['Difference'] / pivot_df['run-01']) * 100

    # Group by VertLevel and calculate summary statistics across participants
    summary = pivot_df.groupby('VertLevel').agg({
        'run-01': ['mean', 'std'],
        'run-02': ['mean', 'std'],
        'Difference': ['mean', 'std'],
        'Percent_Change': ['mean', 'std']
    })

    # Flatten column names
    summary.columns = ['_'.join(col).strip() for col in summary.columns.values]

    # Format the summary
    summary = summary.round(2)
    summary = summary.sort_index(ascending=False)

    # Sort rows chronologically
    summary = summary.reindex(LEVELS)

    print("Summary statistics for each VertLevel:")
    print(summary.to_string())

    return summary


def main():
    # Parse the command line arguments
    parser = get_parser()
    args = parser.parse_args()

    # -------------------------------
    # Parse input args, check if the files exist
    # -------------------------------
    # CSV with metrics
    csv_file_path = os.path.abspath(os.path.expanduser(args.i))

    if not os.path.isfile(csv_file_path):
        raise ValueError(f'ERROR: {args.i} does not exist.')

    # Get the path to the input directory
    path_in = os.path.dirname(csv_file_path)

    # Dump log file there
    fname_log = os.path.join(path_in, 'T2w_violin_plots_all_levels_two_runs.log')
    if os.path.exists(fname_log):
        os.remove(fname_log)
    fh = logging.FileHandler(os.path.join(path_in, fname_log))
    logging.root.addHandler(fh)

    # -------------------------------
    # Read and prepare the data
    # -------------------------------
    logger.info(f"Reading {csv_file_path}...")
    df = read_metrics(csv_file_path)

    # Print number of unique subjects
    number_of_subjects = df["Participant"].nunique()
    logger.info(f'CSV file: Number of unique subjects: {number_of_subjects}')

    summary = compute_difference_between_runs(df)

    # -------------------------------
    # Plotting
    # -------------------------------
    fname_out = os.path.join(path_in, 'T2w_violin_plots_all_levels_two_runs.png')
    # swarmplot + lineplot
    generate_figure(df, summary, fname_out)


if __name__ == "__main__":
    main()
